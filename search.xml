<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[杂谈之什么是FullGC]]></title>
    <url>%2F2019%2F11%2F14%2Ffullgc%2F</url>
    <content type="text"><![CDATA[本文基于JDK 1.8，使用的收集器为ParNew + CMS 前言这篇文章的起因是这样的，在上周五凌晨很苦逼得参加双十一压测值班的时候，有个业务方突然打电话来说我们提供的客户端存在内存泄漏问题导致线上应用持续full gc,本来已经快要睡着的我立马就精神起来了，一通排查，最终定位到了确实是客户端有个bug会导致部分数据会被一直持有进入老年代之后gc不掉，从而就导致了老年代的频繁gc，具体bug暂且不表，有一个很奇怪的现象引起了我的注意，那就是从监控系统上来看，这个应用平均一分钟full gc次数高达十多次，按照我之前的理解full gc时是会stop the world的，stop the world的频率这么高，那么应用自身的服务已经跪掉了啊，但是看这个应用的业务指标监控，居然一切正常，这就有点超出我的理解能力了，后面为了解决这个疑问，针对什么是full gc，以及如何查看full gc的次数等查阅了很多资料，总算搞懂了full gc这个概念，在查资料的过程中发现中文社区里面包含太多错误的信息了，而且大多都是抄来抄去的，非常误导人，因此打算写一篇文章，对一些错误观点进行纠正。 正文前置知识点在真正开始探索Full GC之前，我们需要先介绍几个概念 GCGC 全称为garbage collection,中文含义为垃圾回收，在jvm中的含义为回收无用内存空间 Young space中文名为年轻代或者新生代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较短的对象 Tenured space中文名为老年代或年老代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较长的对象 Minor GCminor gc指的是发生在年轻代或者说新生代（Young space）中的gc，也有人称其为young gc或者ygc,在下文中我们统一使用minor gc表示 Major GCmajor gc指的是发生在老年代（Tenured space）中的gc，也有人称为old gc,o gc,cms gc等，在下文我们统一使用major gc表示 stop the world指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现看起来就像是全世界都停止运转了一样,而不论何种gc算法，不论是minor gc还是major gc都会stop the world，区别只在于stop the world的时间长短。 什么是Full GC先说一下结论，Full GC这个概念是没有官方定义的，而且含义还特别混乱，在不同地方表达的含义是不同的，需要就不同的场景分别进行讨论。 大众认知上在通常意义上人们口中说的Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等，这个是最常见的一种认知，很多人也就了解到这个程度，因此在遇到一些特殊场景的时候就会发现实际情况和自己的认知会发生冲突 从GC日志上在gc.log中会发现在部分gc日志头中也有Full GC这样的字眼，这里表示的含义是在这次GC的全过程中，都是Stop The world的状态，也就是说在这次GC的全过程中所有用户线程都是处于暂停的状态，那么在这里要喷一下中文jvm神书《深入理解JVM》了，在第二版第89页有这么一段话： GC 日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配 担保失败之类的问题 .所以才导致STW)。如果是调用System.gc()方法所触发的收集，那么在这里将显示“[Full GC (System)”。 这段话的描述是错误的，因为在前面说过，不论何种gc算法，不论新生代或是老年代，其gc都会发生stop the world，这里正确的描述是这次GC的全过程都是Stop-The-World的 从JDK自带的工具上使用jstat -gc命令能够查看到制定java 线程的gc次数，那么在经过我的多次尝试以及对比之后，我发现了使用jstat 查出来的FGC 次数和时间，实际上指的是老年代的收集器发生Stop the world 的次数和持续时间，对应本文而言，就是CMS收集器的Stop the world次数和时间 其他含义（坑爹版）前面不是说到我在监控大盘上看到这个应用平均一分钟发生了十多次”Full GC”么，在我弄明白了前面两个Full GC的含义之后查看了gc.log文件，随后发现该应用实际上一次Full GC都没有出现，然后咨询了一下提供监控数据的同学，结果他说是通过JMX获取的，代码为： ManagementFactory.getGarbageCollectorMXBeans() 然后众所周知，使用MXBean获取到的只是收集器的执行次数，和Full GC半毛钱关系都没有啊，随后在追问了一下，发现做监控系统的同学直接把CMS收集器的收集次数当做了Full GC的次数来统计，what the fuck？？？？，只能说对于FUll GC的概念真的有很多人是一直没弄懂过的 结束语在这篇文章快写完的时候，用google随便搜了一下就在首页找到一篇对于各类gc概念介绍得比较透彻的文章，和使用度娘一搜首页全是各种抄来抄去的错误文章相比，对比简直是太强烈了，由此得出结论，技术类的资料能在外网查就在外网查吧，省时又省力，最后附上我找到的这篇文章貌似还是plumbr的联合创始人写的，不得不说很给力了]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Full GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础篇 IO系列之File类]]></title>
    <url>%2F2019%2F11%2F09%2FFile%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[本文讨论的JDK版本为1.8.0_181，系统环境为macos FileFile 类的全限定名为 java.io.File,位于rt.jar中，正如《think in java》中介绍的那样，这个类与其叫做File，不如叫做FilePath，因为这个类除了能够表示一个文件之外，还能够表示一个目录，其实这一点也能从源码的第一行注释中看出来，注释如下： An abstract representation of file and directory pathnames 文件和目录地址的抽象表示 在开始分析之前，我们先来看看这个类的构造函数 1. private File(String pathname, int prefixLength) 2. private File(String child, File parent) 3. public File(String pathname) 4. public File(String parent, String child) 5. public File(File parent, String child) 6. public File(URI uri) 总共六个构造函数，其中2个内部的4个公共的，它们的作用都是指定该File类代表的抽象路径，区别在于拼装方式不同，下面就4个公共方法简单介绍一下： public File(String pathname) 将pathname进行标准化处理之后赋值给File类，pathname为此文件或目录的标准路径名字符串,所谓标准路径名就是指不含有重复或多于的分隔符的路径字符串，若pathname中含有多于的分隔符，File类也会把多于的分隔符给过滤掉(例如//User会被处理为/User), 同时pathname可以为相对路径(test/haha)或者绝对路径(/test/haha)，若为相对路径的话，默认的前缀为当前工作目录，也就是System.getProperty(“user.dir”) public File(String parent, String child) 其中的parent表示前缀，只能为路径字符串，child表示后缀，可以为路径字符串也可以为文件名，最终赋值给File类的字符串为 经过标准处理之后的 parent + child public File(File parent, String child) 同上一个方法是一样的，最终赋值给File类的路径为 parent的路径 + child public File(URI uri) 将URL的path赋值给File类，会校验该URL的协议头是否为”file”，若不是会抛出异常 常用方法分析好了，下面开始进入正文，正如先前所说，File类既能表示一个文件也能表示一个目录，那么我们就File类的这两种状态来分别讨论一下 作为文件创建对于文件而言，首要的功能就是创建文件了，毕竟所有的文件操作前提都是你得有个文件File类提供了三个方法用于新建文件，其中一个内部方法，两个静态方法： 1. public boolean createNewFile() 2. public static File createTempFile(String prefix, String suffix) 3. public static File createTempFile(String prefix, String suffix,File directory) public boolean createNewFile() 比较简单，主要作用就是使用创建File类时传进来的路径来创建文件，若该路径中包含的目录不存在则会直接抛异常，若该文件已经存在了则不进行任何操作 public static File createTempFile(String prefix, String suffix)底层调用的也是public static File createTempFile(String prefix, String suffix,File directory),因此我们只需要看一下public static File createTempFile(String prefix, String suffix,File directory)就好了，此方法是一个静态方法，主要作用是用来创建一个临时文件，其中prefix为文件的前缀名，suffix为文件的后缀名，directory为目录，其中前缀必须为长度大于3的字符串，并且只取文件名（例如若传入的前缀为/user/test,那么最终取的前缀为test），后缀若未传则默认为”.tmp”, directory若未传的话默认为系统临时目录，即 System.getProperty(“java.io.tmpdir”); 读写创建了文件之后，我们当然会想要来对文件进行一下读写了,但File类本身并不提供读写功能，对于Fille的读取，我们是通过后面将会提到的字节流和字符流来实现的。 作为文件的特殊情况我们已经讨论完了，接下来再看一下作为目录的情况 作为目录目录特有的操作比较简单 创建创建目录共有两个方法，分别为： 1. public boolean mkdir() 创建当前目录，若父目录不存在，则创建失败若成功创建则返回true，否则返回false 2. public boolean mkdirs() 创建当前目录，若父目录不存在则先创建父目录，若成功创建则返回true，否则返回false 遍历目录目录的遍历是作为目录而言最常用的方法，一共有5个，分别如下： 1. public String[] list() 返回当前目录下所有文件或目录名称字符串数组（不会递归遍历） 2. public String[] list(FilenameFilter filter) 返回当前目录下符合filter过滤条件的所有文件或目录名称字符串数组，其中FilenameFilter是一个接口，提供了accept方法可用于重写（不会递归遍历） 3. public File[] listFiles() 查找当前目录下所有文件或者目录，并以File类的形式返回（不会递归遍历） 4. public File[] listFiles(FilenameFilter filter) 同理，会只返回filter过滤后的File类文件 5. public File[] listFiles(FileFilter filter) 查找当前目录下所有文件或者目录，并以File类的形式返回，会只返回filter过滤后的File文件，这里的FileFilter与FilenameFilter的区别在于FilenameFilter的入参是String，而FileFilter的入参为File类 公有方法作为文件和目录都有的方法： 1. public boolean canRead() 是否可读 2. public boolean canWrite() 是否可写 3. public boolean exists() 判断当前目录或文件是否存在 4. public boolean isDirectory() 判断当前是否为目录 5. public boolean isFile() 判断当前是否为文件 6. public boolean isHidden() 是否为隐藏文件 7. public boolean delete() 删除文件或者目录，立即删除 8. public void deleteOnExit() 删除文件或者目录，当java进程退出时执行 9. public boolean renameTo(File dest) 将文件或者目录改名为传入的File类的pathName，若目标目录或者文件已存在，则返回失败]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>File类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于flag的那些事]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%AB%8B%E4%B8%AAflag%E5%90%A7%2F</url>
    <content type="text"><![CDATA[周末就喜欢瞎想，虽然还有一大堆事情没有做 模拟退火与布朗运动前段时间看到了一个挺有意思的观点： 人生的优化问题可以通过数学的概念抽象为如下两点 1. 以你想成为什么样的人作为目标函数 2. 将你必须要做的事作为约束条件 上述两个条件的有无，就决定了你目前的状态到底是做的模拟退火还是布朗运动 乍一想，貌似还有那么点道理，想了一下毕业这三年来自己的一个状态，可以说算是典型的布朗运动了，每一个对未来有重大意义和影响的决定，都没有任何理由和思考，都是在周围环境或他人的影响下随波逐流，没有想清楚过自己做的这些决定与完成自己的终极目标方向是否一致，包括刚毕业时拿到offer去上海，其实那个时候根本没有想过为什么要去上海，去上海想要得到些什么，只是当时莫名地觉得去上海发展会好一点（其实也是周围人的说法，与自己而言没什么感触），然后就是最近跳槽到杭州，我又为什么要来杭州，来杭州之后我又想要得到些什么，做这些事能够帮助我实现我的最终目标吗？这些都没有想过，就像一个小分子，做着无规律的布朗运动 想一想，今年马上就25了，已经一把年纪了，是时候弄清楚自己到底想要些什么了，生活还是需要有个方向的。 梳理一下首先，就个人来说，终极目标就三个，第一个是健康的身体，第二个是充足的财富，第三个是足够的时间，相信这也是大多数人所想要的，接下来再按照这三个目标进行一下细分，梳理一下约束条件。 健康的身体要拥有一个健康的身体，除了一些不可抗因素之外，坚持做到三个方面应该就OK了 1. 良好的作息时间 2. 良好的饮食习惯 3. 合理的锻炼时间 就上述三个方面，分别制定一条约束条件 1. 拒绝熬夜，每天11点前睡觉，6~7点钟起床 2. 每日三餐，按时吃饭，避免暴饮暴食，过度油腻 3. 每日半小时锻炼时间，可跑步或其他 充足的财富那么有多少财富算是充足的财富呢，答案是再多也不够，未来会发生什么我们永远也不知道，可能现在觉得完全足够的钱在未来会变得远远不够，现在觉得非常稳定的工作到未来也可能在眨眼之间失业，所以要保证有充足的财富个人认为应该做到有这两方面 1. 保持自己的竞争力，个人成长必须跟上以及超过时间的流逝，不论何时，都能够靠个人能力赚到足够生活的钱，可以为大公司打工，也可以是作为自由职业者，总之就是能够通过劳动换来报酬。 2. 在不工作的情况下也能有源源不断的现金流，换句话说就是要有真正属于自己的事业，或者说资本，然后用资本为自己赚钱。 只要能够做到上述两点，那么随着时间的过去，总会积累下足够的财富，因为这是一个良性循环的过程。 那么就这两个方面，我们来看一下约束条件 1. 对于保持竞争力这一点，其实说起来很简单，就一句话：持续学习，确定好自己从事的专业方向，然后保持每天或是每周都花费足够的时间学习这个方向的相关知识，或是打磨技能，就能够一直保持自己的竞争力，当然这里的持续是真正意义的持续，不能因为任何原因停止 2. 对于资本，目前自己也不清楚如何建立自己的资本，唯一能想到的就是不断拓宽自己的眼界，寻找值得投资的机会 足够的时间足够的时间就是指能够有时间做自己真正想要做的事，比如，每天去一下健身房，去一下英语培训班，或者音乐班，以及和三五好友聚会，独自去旅行等等。这一项是最难以实现的，因为通常财富都是在牺牲时间的前提下换来的，举个例子，对于小码农来说，每天早上起床就是上班，下班回家之后就是睡觉，所有的时间全部在公司里面，已经和整个社会脱节了，像很普通的下班之后看个电影吃个饭，逛逛商场之类的活动对于程序员(中国的)来说是遥不可及的，因为下班的时候绝大部分店都已经关门了，因此对于程序员这类用全部时间换钱的职业来说，是不可能有充足的时间的。 那么要做到这一项，我们都些什么呢 1. 其实我们只需要有足够的财富，也就是得先实现上一个目标，并且这个实现得是建立在构建了自己的资本之后，因为为别人打工的情况下，老板总是想要花最少的钱，买你最多的时间，哪怕多出来的这些时间对他来说没有任何价值（这是因为中国大部分管理者管理能力都很低下，只把员工当做劳动密集型工种在使用），有了自己的资本之后，就会有很多人花他们的时间来为你赚钱，而你自然就会有足够的时间 那么这一条的约束条件是什么呢 其实同上一条的约束条件类似，就是一定要拥有自己的资本，就现状而言，我们可以努力提升自己的竞争力，拓宽自己的眼界，同时学会理财，积累好自己的原始资本，在有机会的情况下，毫不犹豫地去创建自己的资本 结束语梳理了这么一遍之后，为自己制定了一个新的计划，首先，按照第一个约束条件做到良好的作息时间和锻炼等，这是所有flag的前提，需要一直坚持下去，其次，平时立的一些短期flag(例如每年的计划表，每月计划表等)需要将最终目标设置为提高自己的竞争力，这样就能满足第二条约束条件，最后，多接触新鲜事物，多思考，多结识新的朋友，这样就能满足最后一条约束条件]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人对高并发服务的理解]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结一下 前言本文主要是简单介绍一下一个服务由单机部署到分布式部署，访问流量从低到高，这个过程中，我们所使用到的相关技术，以及需要主要到的点 由于本人水平极其有限，因此有什么错误的地方(感觉会有很多)欢迎大家指出 一些概念： 多核cpu以及超线程技术： 逻辑cpu核数: 物理cpu数 * cpu 核数 * 超线程数 cpu的load average：即cpu当前负载，举个栗子，若一个cpu1分钟能够处理的进程数是100，然后在这一分钟内只有20个进程需要被处理，那么当前cpu的负载为20/100 = 0.2通常一台机器的load average不应当超过0.7 * 逻辑cpu核数，当超过了就应当去查找原因，要是达到 1.0 * 逻辑cpu核数 那么就必须要想办法降下来 QPS(Query Per Second):即每秒查询率,是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准 TPS(TransactionPerSecond):即每秒事务处理量，指每秒钟系统能够处理的交易或事务的数量 提高单机性能-多线程技术：多线程是否一定能提升效率：首先需要明确一点，多线程只是将一个大的计算任务分为了多个并行的小的计算任务，这些拆分出来的任务还是需要分别去抢占cpu时间片，总体需要花费的时间并没有减少，只是使得任务可以并行执行 因此多线程能够提升程序执行效率的一个关键点是这台机器上的cpu，如果是单核的话，多线程反而比单线程慢因为增加了上下文切换的开销，同时对于多核cpu来说线程数也不是越多越好，举个例4核8线程的cpu 能够同时处理的任务也就8个，起再多线程也没用，反而会增加不必要的开销，通常来说保证同时处理的 线程数 = N(CPU核心数) + 1 能使系统效率达到最优，当然这里是指计算密集型线程，如果是io密集型的话可以适当增加线程数因为io线程并不一定会去抢占cpu 关于线程安全：什么是线程安全，感觉说法很多，个人理解线程安全问题就是你写的代码在多线程的情况下执行结果没有达到期望的目标比如hashmap在多线程的场景下在resize的时候有一定几率导致死循环，以及多个线程同时对同一个变量进行compare and set操作等总结了一下能产生线程安全的一个必要条件就是先得有多个线程同时访问并操作同一个数据，所以我们在写代码的时候需要注意当定义了一个static 类型的变量，或者是类成员变量时需要考虑是否会出现线程安全问题如果有可能出现线程安全问题，首先可以考虑一下用threadLocal能否解决问题，如果不能则需要考虑合理使用锁（不论是synchronized关键字还是lock类），但是使用锁的时候也需要注意是否会出现两个线程循环依赖，导致出现死锁的情况。 集群化服务-分布式部署：所谓分布式服务，个人理解就是服务和资源分散部署到不同的机器上使用原因是因为单机部署存在一个机器性能瓶颈，以及单点问题，所以线上所有服务都是多机部署的。当线上的流量变大了之后，以及提供服务的机器多了之后，如何去分发这些流量，以及流量都应该分发到哪台机器上这就是负载均衡解决的问题 流量转发-负载均衡：负载均衡分为4层负载均衡和7层负载均衡，其中4层负载均衡作用于OSI模型的第四层传输层，这一层主要的协议是tcp和udp，由此可以知道这一层负载均衡的作用主要是对数据包的转发通常客户端的流量过来了之后到达4层负载均衡，然后4层负载均衡通过修改数据包的地址信息将流量转发到应用服务器 7层负载均衡的话作用于OSI模型的第7层应用层，主要工作为代理，在将应用层的流量完整解析出来之后，7层负载均衡会新建一个连接到实际需要访问的机器上，将解析出的请求投递过去 公司现状：4层负载均衡使用的自研mgw，7层(web端)用的nginx或者Tengine，然后实际到service端的时候是使用的rpc服务自带的负载均衡附上一篇文章 MGW RPCRPC服务主要是为了简化部署在不同机器上的不同服务之间的相互调用不多讲，甩篇文章先 RPC 数据量日益增加-分库分表：现在线上提供服务的机器已经由一台变成多台了，并且能够水平扩展，因此在某种程度上已经解决了高访问量的问题(其实并没有)加机器就好了嘛，但接下来还是会遇到各种各样的问题首先一个比较容易想到的是当服务在线运行时间比较久或者访问量比较大之后，通常会导致数据库中或者表中的数据量越来越大，当数据量大了之后不论是插入还是查询都会变慢长此以往，直接就会导致我们的服务不可用,并且这种场景下扩几台应用机都没用，那么机智的小伙伴肯定想到了，扩应用机没用，扩DB不就行了么，答案确实是这样的，只不过我们用了一个比较高端的名词–分库分表所谓分库分表，其实就是将一个库或者表的数据分散到不同的库，或者不同的表中，然后通过提前定义好的分库规则和分表规则去访问不同库表，降低单库单表访问压力提高读写性能(ps:其实分库分表的前置技术栈还有一个读写分离技术，篇幅有限，就不说了，大致提一句就是单库写，多库读) 一些关注点分库分表的临界值 单表数量不超过1000万 单库数据量不超过300G 分库分表之后会遇到的问题 基本的数据库增删改功能 分布式id 分布式事务 动态扩容 使用zebra进行分库分表： 最后甩个链接 zebra 读多写少-缓存的使用：当把数据量的问题解决了之后，随着业务的发展服务访问量日益增加，你会发现读写分离+分库分表能处理的请求量(这里指qps或Tps，不过通常都是读压力比较大)还是有限，这就是所谓的DB瓶颈针对这种情况一个常用的优化措施就是缓存，利用缓存的高吞吐量的特性，在db前部署一层缓存可以大大降低db的负载，同时通常缓存响应的速度比db快(内存缓存)，因此在提高吞吐量的情况下还提高了访问速度，简直妙啊 redis和tair介绍:redis 纯内存K-V缓存，支持5种数据结构String、Hash 、List 、 Set 、 ZSet tair 淘宝开源 内存结构主要看存储引擎选择，例如MDB，LDB等 具体可见jiajun大佬的分享: 大佬的分享Redis AND 大佬的分享Tair 使用缓存需要注意的问题 缓存穿透通常在缓存未命中的情况下我们回去db再查一次数据，要是有人使用不存在的key来请求，那么流量就相当于直接落在db上 解决方案：访问db前进行合理性校验 缓存击穿单个key在过期的一瞬间被大量请求访问 解决方案：在访问db前，先加个互斥锁，例如setnx 缓存雪崩批量key在同一时间过期，大量请求直接到达db，然后db负载飙升，引起雪崩 解决方案：采用不同的过期时间，例如在固定过期时间的基础上加上一个随机值 不必要流程的异步化-MQ：那么在原有的系统上加上一层缓存之后就可以高枕无忧了么，答案当然是NO，下面列举一些场景： 写流量非常高 缓存通常只被用来解决读性能问题，最终数据一致性还是要靠db来保证(其实就是要把数据刷到磁盘上)，因此不可能将所有的写都放到缓存上 瞬时流量暴增 系统流量在短时间内倍增，例如节日或者活动期间，突发流量很有可能将缓存直接压垮，然后系统GG 针对这些问题，乍一看似乎是没什么好的办法可以解决了(其实有，但是我不知道)，不过针对某些特殊的场景我们还是可以优化一下的比如： 我如果能减少每个请求的处理时间，那么是不是就能够提高我单机的qps，那么瞬时流量来的时候是不是就不至于压夸整个系统了 对于写请求的话如果对于响应时间的要求不是那么高，那么先把这些请求都保存下来，然后慢慢处理不就好了 针对第一种优化方案，我们能想到的一个点是将系统流程中的一些不那么重要的分支流程由同步改为异步，例如更新缓存的操作然后第二种优化方案其实也是一种异步化的思想，将同步的事改为异步去做，只要保证最终一致性就好了。 那么怎么来实现这种异步化操作呢，这个时候就轮到MQ(MessageQueue)大佬出场了。 所谓MQ，其实就是一个生产者-消费者模型，producer负责生产消息，然后consumer消费消息，中间还有一个broker用来保存生产的消息像我们刚才说的这些场景我们可以让我们的服务器既作producer又做consumer，将需要异步处理的任务统统先发送到broker,然后慢慢取回来消费当然MQ也并没有我说的这么简单，篇幅有限加上个人能力有限我这里就不细说了，具体可以看看我司大佬的博文 这个是大佬文章 kafka介绍:我司使用的MQ是mafka，其实就是封装了一下kafka，针对kafka篇幅有限加上个人能力有限也不细说了，简单介绍一下 提升可用性-限流和熔断降级：当系统的可用性依赖与其他服务的可用性时，熔断降级机制是提升系统本身可使用性的一大利器同时针对突发流量，限流工具的使用也是相当有必要的 rhino介绍：Rhino]]></content>
  </entry>
  <entry>
    <title><![CDATA[java程序员基本素养(二) 更复杂的java程序]]></title>
    <url>%2F2018%2F07%2F19%2Fjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB2%2F</url>
    <content type="text"><![CDATA[何如使用中间件，工具等只是术的层次，我们更需要关注背后的道的层次 io要写功能更强大的程序，不可避免要涉及io，不论是从文件中获取还是从网络中获取 java.io 库 待填坑 bio、nio、aio 对比 待填坑 我司大佬写的NIO 网络编程除非你一直都是写单机程序自娱自乐，不然我们总会需要将自己的服务发布到网络上 java网络编程 待填坑 多线程现在的计算机通常都不止一个CPU，同时由于CPU的超线程技术，可以使一个CPU同时处理两个线程，使得计算机的计算能力大幅提升为了更好地压榨机器的性能，多线程编程技术必不可少 Java多线程 待填坑 ThreadPoolExecutor 我写的]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>java程序员基本素养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java程序员基本素养(一) 从java文件到在JVM中运行]]></title>
    <url>%2F2018%2F07%2F12%2Fjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB%2F</url>
    <content type="text"><![CDATA[个人理解的作为一个java程序员应当有的基本素养系列，只维护一个目录作为查缺补漏用 .java 文件java 码农生涯的起点是从一个.java文件开始的 java语法 待填坑 .class 文件.java 文件通过javac编译后每个类都会生成一个.class文件.class文件是JVM生态圈里比较重要的一部分，也是java实现跨平台部署的基础 .class 文件结构 待填坑 字节码指令含义 待填坑 这个不错 java语法如何转换为字节码(不那么重要) 待填坑 .class 文件加载进内存中要使用.class文件先得把.class文件加载到内存中 类加载机制 待填坑 内存中的.class文件如何转化为机器码字节码还是能被JVM识别，但是正在进行运算的还是机器本身，所以需要把字节码转化为可被机器识别的机器码 解释器编译器，JIT等 待填坑 GC程序运行起来之后，在运行过程中需要不断地申请和释放内存，怎么来分配和回收内存就需要我们关注一下了，我们通常使用的VM都是hotspot VMhotspot VM为我们提供了很多的垃圾收集器 JVM 内存分配方案(hotSpot) 待填坑 JVM 收集器(hotSpot) 待填坑 Java 常用调试工具(jsp,jmap,jstack等) 待填坑]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>java程序员基本素养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统一电话服务]]></title>
    <url>%2F2018%2F06%2F02%2F%E7%BB%9F%E4%B8%80%E7%94%B5%E8%AF%9D%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[统一电话服务模块化改造目标将现有服务按功能拆分为独立模块,内部系统结构改为各个模块之间通信的方式，减少冗余代码，解耦各个模块之间的依赖提高代码可读性和可维护性 模块划分经过对系统功能的梳理，一共划分为了如下5个互相解耦的模块，每个模块大致功能如下 校验及数据转化模块 系统中所有需要进行数据校验的操作，包括参数校验，返回值校验，以及需要进行数据转换的服务，包括16进制转10进制，码表转换等，由此模块对外提供 加解密模块 系统中所有需要进行加解密的操作，由此模块对外提供 存储模块 系统中所有需要进行存储的操作全部由此模块提供，包括缓存，db等，同时内置缓存同步策略，路由策略，降级策略，限流策略等 LeafID生成模块 系统内所有leafID的来源，内部包含预拉取，内存队列优化，熔断降级等策略 监控模块 负责监控系统运行状态，对数据进行分析并告警 模块通信方式目前采取的策略是，每个模块各对外暴露一个接口，再由内部实现类去对各个模块进行操作，其中监控模块采用AOP的方式，捕获其他所有模块的返回值及抛出的异常。 存储模块详细设计在所有模块中，存储模块是逻辑最复杂的一块，细分的话可以分为缓存模块和db模块。 缓存模块缓存模块作为高可用最重要的一环，因此相当重要，故而采取了以下策略，尽可能保证缓存服务的稳定 异地双中心部署 当一个请求到缓存模块时会判断地区信息，调用不同的缓存集群 熔断降级 采取redis、tair双缓存互为备份的方案,默认由redis提供服务，一旦redis出现异常，自动降级到tair 缓存结构优化(主要针对redis) 将string类型调整为hash类型，将key的数量级由亿降至百万，降低存储内存占用 db模块db主要用于保证数据可靠，因此重点在于不能有任何脏数据落库，除此之外还要保证db的高可用，不能被突增流量打垮，因此db模块工作如下： 限流 使用公司内部限流框架对写接口进行限流 分布式锁 落库操作其实是一类compareAndSet的操作，对于一条数据会首先查询db中有没有，没有再落库但是在并发量比较高的情况下多个线程同时写同一条数据的时候，会产生往数据库中插入同一条记录的问题,对于这个问题我们的解决方式是为每个写入操作添加一个分布式锁，过期时间为1s，当写同一条数据时，只有一个线程能获取到锁，未获取到锁的线程则等待其他线程写入，然后查询返回 leafID模块详细设计 维护线程池预拉取数据到db,数据默认从db中获取 当db中获取数据失败时，自动降级到远程调用 获取到的数据先全部缓存到内存队列中，所有外部调用都从队列中取值]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>美团点评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些想法]]></title>
    <url>%2F2018%2F01%2F03%2F%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我想要的无非是看得见的未来和到得了的远方 过去独身一人，懵懂无知，得过且过 现在虽然还是一条咸鱼，还是那么无能，但是拥有了你，好像明白了很多事情 未来成为自己一直想成为的那个人，不再当一条令人恶心的咸鱼 总结人生路长，风景很多，值得我们付出所有的努力去到更远的地方，看到更好的风景 当然，最重要的是，不论旅途艰辛与否，风景动人还是令人失望，身边始终有你 — kep 于2018年1月3日晚 胡言乱语]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咸鱼之家今天正式成立啦]]></title>
    <url>%2F2017%2F11%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[“双11，别人在剁手，我在码代码” 前言在换了几个大众化的博客之后终于想要自己来搭一个博客环境了。 当然作为一个只会html，css，JavaScript等单词拼写的人 写前端是不会写的，只能勉强靠着copy大佬的代码才能勉强有个能看的界面这个样子 于是周末花了一天时间找了一堆大佬们模板，最终选择了用这个看这里 毕竟反正自己不会写，用哪个都是一样的 正文以后打算在这里写一写平时自己学到的新姿势，生活中的一些瞎想等等 欢迎各位基佬前来围观 —— kep 于 2017年 11.11]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
</search>
