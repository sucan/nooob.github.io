<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于flag的那些事]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%AB%8B%E4%B8%AAflag%E5%90%A7%2F</url>
    <content type="text"><![CDATA[周末就喜欢瞎想，虽然还有一大堆事情没有做 模拟退火与布朗运动前段时间看到了一个挺有意思的观点： 人生的优化问题可以通过数学的概念抽象为如下两点 1. 以你想成为什么样的人作为目标函数 2. 将你必须要做的事作为约束条件 上述两个条件的有无，就决定了你目前的状态到底是做的模拟退火还是布朗运动 乍一想，貌似还有那么点道理，想了一下毕业这三年来自己的一个状态，可以说算是典型的布朗运动了，每一个对未来有重大意义和影响的决定，都没有任何理由和思考，都是在周围环境或他人的影响下随波逐流，没有想清楚过自己做的这些决定与完成自己的终极目标方向是否一致，包括刚毕业时拿到offer去上海，其实那个时候根本没有想过为什么要去上海，去上海想要得到些什么，只是当时莫名地觉得去上海发展会好一点（其实也是周围人的说法，与自己而言没什么感触），然后就是最近跳槽到杭州，我又为什么要来杭州，来杭州之后我又想要得到些什么，做这些事能够帮助我实现我的最终目标吗？这些都没有想过，就像一个小分子，做着无规律的布朗运动 想一想，今年马上就25了，已经一把年纪了，是时候弄清楚自己到底想要些什么了，生活还是需要有个方向的。 梳理一下首先，就个人来说，终极目标就三个，第一个是健康的身体，第二个是充足的财富，第三个是足够的时间，相信这也是大多数人所想要的，接下来再按照这三个目标进行一下细分，梳理一下约束条件。 健康的身体要拥有一个健康的身体，除了一些不可抗因素之外，坚持做到三个方面应该就OK了 1. 良好的作息时间 2. 良好的饮食习惯 3. 合理的锻炼时间 就上述三个方面，分别制定一条约束条件 1. 拒绝熬夜，每天11点前睡觉，6~7点钟起床 2. 每日三餐，按时吃饭，避免暴饮暴食，过度油腻 3. 每日半小时锻炼时间，可跑步或其他 充足的财富那么有多少财富算是充足的财富呢，答案是再多也不够，未来会发生什么我们永远也不知道，可能现在觉得完全足够的钱在未来会变得远远不够，现在觉得非常稳定的工作到未来也可能在眨眼之间失业，所以要保证有充足的财富个人认为应该做到有这两方面 1. 保持自己的竞争力，个人成长必须跟上以及超过时间的流逝，不论何时，都能够靠个人能力赚到足够生活的钱，可以为大公司打工，也可以是作为自由职业者，总之就是能够通过劳动换来报酬。 2. 在不工作的情况下也能有源源不断的现金流，换句话说就是要有真正属于自己的事业，或者说资本，然后用资本为自己赚钱。 只要能够做到上述两点，那么随着时间的过去，总会积累下足够的财富，因为这是一个良性循环的过程。 那么就这两个方面，我们来看一下约束条件 1. 对于保持竞争力这一点，其实说起来很简单，就一句话：持续学习，确定好自己从事的专业方向，然后保持每天或是每周都花费足够的时间学习这个方向的相关知识，或是打磨技能，就能够一直保持自己的竞争力，当然这里的持续是真正意义的持续，不能因为任何原因停止 2. 对于资本，目前自己也不清楚如何建立自己的资本，唯一能想到的就是不断拓宽自己的眼界，寻找值得投资的机会 足够的时间足够的时间就是指能够有时间做自己真正想要做的事，比如，每天去一下健身房，去一下英语培训班，或者音乐班，以及和三五好友聚会，独自去旅行等等。这一项是最难以实现的，因为通常财富都是在牺牲时间的前提下换来的，举个例子，对于小码农来说，每天早上起床就是上班，下班回家之后就是睡觉，所有的时间全部在公司里面，已经和整个社会脱节了，像很普通的下班之后看个电影吃个饭，逛逛商场之类的活动对于程序员(中国的)来说是遥不可及的，因为下班的时候绝大部分店都已经关门了，因此对于程序员这类用全部时间换钱的职业来说，是不可能有充足的时间的。 那么要做到这一项，我们都些什么呢 1. 其实我们只需要有足够的财富，也就是得先实现上一个目标，并且这个实现得是建立在构建了自己的资本之后，因为为别人打工的情况下，老板总是想要花最少的钱，买你最多的时间，哪怕多出来的这些时间对他来说没有任何价值（这是因为中国大部分管理者管理能力都很低下，只把员工当做劳动密集型工种在使用），有了自己的资本之后，就会有很多人花他们的时间来为你赚钱，而你自然就会有足够的时间 那么这一条的约束条件是什么呢 其实同上一条的约束条件类似，就是一定要拥有自己的资本，就现状而言，我们可以努力提升自己的竞争力，拓宽自己的眼界，同时学会理财，积累好自己的原始资本，在有机会的情况下，毫不犹豫地去创建自己的资本 结束语梳理了这么一遍之后，为自己制定了一个新的计划，首先，按照第一个约束条件做到良好的作息时间和锻炼等，这是所有flag的前提，需要一直坚持下去，其次，平时立的一些短期flag(例如每年的计划表，每月计划表等)需要将最终目标设置为提高自己的竞争力，这样就能满足第二条约束条件，最后，多接触新鲜事物，多思考，多结识新的朋友，这样就能满足最后一条约束条件]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人对高并发服务的理解]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结一下 前言本文主要是简单介绍一下一个服务由单机部署到分布式部署，访问流量从低到高，这个过程中，我们所使用到的相关技术，以及需要主要到的点 由于本人水平极其有限，因此有什么错误的地方(感觉会有很多)欢迎大家指出 一些概念： 多核cpu以及超线程技术： 逻辑cpu核数: 物理cpu数 * cpu 核数 * 超线程数 cpu的load average：即cpu当前负载，举个栗子，若一个cpu1分钟能够处理的进程数是100，然后在这一分钟内只有20个进程需要被处理，那么当前cpu的负载为20/100 = 0.2通常一台机器的load average不应当超过0.7 * 逻辑cpu核数，当超过了就应当去查找原因，要是达到 1.0 * 逻辑cpu核数 那么就必须要想办法降下来 QPS(Query Per Second):即每秒查询率,是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准 TPS(TransactionPerSecond):即每秒事务处理量，指每秒钟系统能够处理的交易或事务的数量 提高单机性能-多线程技术：多线程是否一定能提升效率：首先需要明确一点，多线程只是将一个大的计算任务分为了多个并行的小的计算任务，这些拆分出来的任务还是需要分别去抢占cpu时间片，总体需要花费的时间并没有减少，只是使得任务可以并行执行 因此多线程能够提升程序执行效率的一个关键点是这台机器上的cpu，如果是单核的话，多线程反而比单线程慢因为增加了上下文切换的开销，同时对于多核cpu来说线程数也不是越多越好，举个例4核8线程的cpu 能够同时处理的任务也就8个，起再多线程也没用，反而会增加不必要的开销，通常来说保证同时处理的 线程数 = N(CPU核心数) + 1 能使系统效率达到最优，当然这里是指计算密集型线程，如果是io密集型的话可以适当增加线程数因为io线程并不一定会去抢占cpu 关于线程安全：什么是线程安全，感觉说法很多，个人理解线程安全问题就是你写的代码在多线程的情况下执行结果没有达到期望的目标比如hashmap在多线程的场景下在resize的时候有一定几率导致死循环，以及多个线程同时对同一个变量进行compare and set操作等总结了一下能产生线程安全的一个必要条件就是先得有多个线程同时访问并操作同一个数据，所以我们在写代码的时候需要注意当定义了一个static 类型的变量，或者是类成员变量时需要考虑是否会出现线程安全问题如果有可能出现线程安全问题，首先可以考虑一下用threadLocal能否解决问题，如果不能则需要考虑合理使用锁（不论是synchronized关键字还是lock类），但是使用锁的时候也需要注意是否会出现两个线程循环依赖，导致出现死锁的情况。 集群化服务-分布式部署：所谓分布式服务，个人理解就是服务和资源分散部署到不同的机器上使用原因是因为单机部署存在一个机器性能瓶颈，以及单点问题，所以线上所有服务都是多机部署的。当线上的流量变大了之后，以及提供服务的机器多了之后，如何去分发这些流量，以及流量都应该分发到哪台机器上这就是负载均衡解决的问题 流量转发-负载均衡：负载均衡分为4层负载均衡和7层负载均衡，其中4层负载均衡作用于OSI模型的第四层传输层，这一层主要的协议是tcp和udp，由此可以知道这一层负载均衡的作用主要是对数据包的转发通常客户端的流量过来了之后到达4层负载均衡，然后4层负载均衡通过修改数据包的地址信息将流量转发到应用服务器 7层负载均衡的话作用于OSI模型的第7层应用层，主要工作为代理，在将应用层的流量完整解析出来之后，7层负载均衡会新建一个连接到实际需要访问的机器上，将解析出的请求投递过去 公司现状：4层负载均衡使用的自研mgw，7层(web端)用的nginx或者Tengine，然后实际到service端的时候是使用的rpc服务自带的负载均衡附上一篇文章 MGW RPCRPC服务主要是为了简化部署在不同机器上的不同服务之间的相互调用不多讲，甩篇文章先 RPC 数据量日益增加-分库分表：现在线上提供服务的机器已经由一台变成多台了，并且能够水平扩展，因此在某种程度上已经解决了高访问量的问题(其实并没有)加机器就好了嘛，但接下来还是会遇到各种各样的问题首先一个比较容易想到的是当服务在线运行时间比较久或者访问量比较大之后，通常会导致数据库中或者表中的数据量越来越大，当数据量大了之后不论是插入还是查询都会变慢长此以往，直接就会导致我们的服务不可用,并且这种场景下扩几台应用机都没用，那么机智的小伙伴肯定想到了，扩应用机没用，扩DB不就行了么，答案确实是这样的，只不过我们用了一个比较高端的名词–分库分表所谓分库分表，其实就是将一个库或者表的数据分散到不同的库，或者不同的表中，然后通过提前定义好的分库规则和分表规则去访问不同库表，降低单库单表访问压力提高读写性能(ps:其实分库分表的前置技术栈还有一个读写分离技术，篇幅有限，就不说了，大致提一句就是单库写，多库读) 一些关注点分库分表的临界值 单表数量不超过1000万 单库数据量不超过300G 分库分表之后会遇到的问题 基本的数据库增删改功能 分布式id 分布式事务 动态扩容 使用zebra进行分库分表： 最后甩个链接 zebra 读多写少-缓存的使用：当把数据量的问题解决了之后，随着业务的发展服务访问量日益增加，你会发现读写分离+分库分表能处理的请求量(这里指qps或Tps，不过通常都是读压力比较大)还是有限，这就是所谓的DB瓶颈针对这种情况一个常用的优化措施就是缓存，利用缓存的高吞吐量的特性，在db前部署一层缓存可以大大降低db的负载，同时通常缓存响应的速度比db快(内存缓存)，因此在提高吞吐量的情况下还提高了访问速度，简直妙啊 redis和tair介绍:redis 纯内存K-V缓存，支持5种数据结构String、Hash 、List 、 Set 、 ZSet tair 淘宝开源 内存结构主要看存储引擎选择，例如MDB，LDB等 具体可见jiajun大佬的分享: 大佬的分享Redis AND 大佬的分享Tair 使用缓存需要注意的问题 缓存穿透通常在缓存未命中的情况下我们回去db再查一次数据，要是有人使用不存在的key来请求，那么流量就相当于直接落在db上 解决方案：访问db前进行合理性校验 缓存击穿单个key在过期的一瞬间被大量请求访问 解决方案：在访问db前，先加个互斥锁，例如setnx 缓存雪崩批量key在同一时间过期，大量请求直接到达db，然后db负载飙升，引起雪崩 解决方案：采用不同的过期时间，例如在固定过期时间的基础上加上一个随机值 不必要流程的异步化-MQ：那么在原有的系统上加上一层缓存之后就可以高枕无忧了么，答案当然是NO，下面列举一些场景： 写流量非常高 缓存通常只被用来解决读性能问题，最终数据一致性还是要靠db来保证(其实就是要把数据刷到磁盘上)，因此不可能将所有的写都放到缓存上 瞬时流量暴增 系统流量在短时间内倍增，例如节日或者活动期间，突发流量很有可能将缓存直接压垮，然后系统GG 针对这些问题，乍一看似乎是没什么好的办法可以解决了(其实有，但是我不知道)，不过针对某些特殊的场景我们还是可以优化一下的比如： 我如果能减少每个请求的处理时间，那么是不是就能够提高我单机的qps，那么瞬时流量来的时候是不是就不至于压夸整个系统了 对于写请求的话如果对于响应时间的要求不是那么高，那么先把这些请求都保存下来，然后慢慢处理不就好了 针对第一种优化方案，我们能想到的一个点是将系统流程中的一些不那么重要的分支流程由同步改为异步，例如更新缓存的操作然后第二种优化方案其实也是一种异步化的思想，将同步的事改为异步去做，只要保证最终一致性就好了。 那么怎么来实现这种异步化操作呢，这个时候就轮到MQ(MessageQueue)大佬出场了。 所谓MQ，其实就是一个生产者-消费者模型，producer负责生产消息，然后consumer消费消息，中间还有一个broker用来保存生产的消息像我们刚才说的这些场景我们可以让我们的服务器既作producer又做consumer，将需要异步处理的任务统统先发送到broker,然后慢慢取回来消费当然MQ也并没有我说的这么简单，篇幅有限加上个人能力有限我这里就不细说了，具体可以看看我司大佬的博文 这个是大佬文章 kafka介绍:我司使用的MQ是mafka，其实就是封装了一下kafka，针对kafka篇幅有限加上个人能力有限也不细说了，简单介绍一下 提升可用性-限流和熔断降级：当系统的可用性依赖与其他服务的可用性时，熔断降级机制是提升系统本身可使用性的一大利器同时针对突发流量，限流工具的使用也是相当有必要的 rhino介绍：Rhino]]></content>
  </entry>
  <entry>
    <title><![CDATA[java程序员基本素养(二) 更复杂的java程序]]></title>
    <url>%2F2018%2F07%2F19%2Fjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB2%2F</url>
    <content type="text"><![CDATA[何如使用中间件，工具等只是术的层次，我们更需要关注背后的道的层次 io要写功能更强大的程序，不可避免要涉及io，不论是从文件中获取还是从网络中获取 java.io 库 待填坑 bio、nio、aio 对比 待填坑 我司大佬写的NIO 网络编程除非你一直都是写单机程序自娱自乐，不然我们总会需要将自己的服务发布到网络上 java网络编程 待填坑 多线程现在的计算机通常都不止一个CPU，同时由于CPU的超线程技术，可以使一个CPU同时处理两个线程，使得计算机的计算能力大幅提升为了更好地压榨机器的性能，多线程编程技术必不可少 Java多线程 待填坑 ThreadPoolExecutor 我写的]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>java程序员基本素养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java程序员基本素养(一) 从java文件到在JVM中运行]]></title>
    <url>%2F2018%2F07%2F12%2Fjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB%2F</url>
    <content type="text"><![CDATA[个人理解的作为一个java程序员应当有的基本素养系列，只维护一个目录作为查缺补漏用 .java 文件java 码农生涯的起点是从一个.java文件开始的 java语法 待填坑 .class 文件.java 文件通过javac编译后每个类都会生成一个.class文件.class文件是JVM生态圈里比较重要的一部分，也是java实现跨平台部署的基础 .class 文件结构 待填坑 字节码指令含义 待填坑 这个不错 java语法如何转换为字节码(不那么重要) 待填坑 .class 文件加载进内存中要使用.class文件先得把.class文件加载到内存中 类加载机制 待填坑 内存中的.class文件如何转化为机器码字节码还是能被JVM识别，但是正在进行运算的还是机器本身，所以需要把字节码转化为可被机器识别的机器码 解释器编译器，JIT等 待填坑 GC程序运行起来之后，在运行过程中需要不断地申请和释放内存，怎么来分配和回收内存就需要我们关注一下了，我们通常使用的VM都是hotspot VMhotspot VM为我们提供了很多的垃圾收集器 JVM 内存分配方案(hotSpot) 待填坑 JVM 收集器(hotSpot) 待填坑 Java 常用调试工具(jsp,jmap,jstack等) 待填坑]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>java程序员基本素养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统一电话服务]]></title>
    <url>%2F2018%2F06%2F02%2F%E7%BB%9F%E4%B8%80%E7%94%B5%E8%AF%9D%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[统一电话服务模块化改造目标将现有服务按功能拆分为独立模块,内部系统结构改为各个模块之间通信的方式，减少冗余代码，解耦各个模块之间的依赖提高代码可读性和可维护性 模块划分经过对系统功能的梳理，一共划分为了如下5个互相解耦的模块，每个模块大致功能如下 校验及数据转化模块 系统中所有需要进行数据校验的操作，包括参数校验，返回值校验，以及需要进行数据转换的服务，包括16进制转10进制，码表转换等，由此模块对外提供 加解密模块 系统中所有需要进行加解密的操作，由此模块对外提供 存储模块 系统中所有需要进行存储的操作全部由此模块提供，包括缓存，db等，同时内置缓存同步策略，路由策略，降级策略，限流策略等 LeafID生成模块 系统内所有leafID的来源，内部包含预拉取，内存队列优化，熔断降级等策略 监控模块 负责监控系统运行状态，对数据进行分析并告警 模块通信方式目前采取的策略是，每个模块各对外暴露一个接口，再由内部实现类去对各个模块进行操作，其中监控模块采用AOP的方式，捕获其他所有模块的返回值及抛出的异常。 存储模块详细设计在所有模块中，存储模块是逻辑最复杂的一块，细分的话可以分为缓存模块和db模块。 缓存模块缓存模块作为高可用最重要的一环，因此相当重要，故而采取了以下策略，尽可能保证缓存服务的稳定 异地双中心部署 当一个请求到缓存模块时会判断地区信息，调用不同的缓存集群 熔断降级 采取redis、tair双缓存互为备份的方案,默认由redis提供服务，一旦redis出现异常，自动降级到tair 缓存结构优化(主要针对redis) 将string类型调整为hash类型，将key的数量级由亿降至百万，降低存储内存占用 db模块db主要用于保证数据可靠，因此重点在于不能有任何脏数据落库，除此之外还要保证db的高可用，不能被突增流量打垮，因此db模块工作如下： 限流 使用公司内部限流框架对写接口进行限流 分布式锁 落库操作其实是一类compareAndSet的操作，对于一条数据会首先查询db中有没有，没有再落库但是在并发量比较高的情况下多个线程同时写同一条数据的时候，会产生往数据库中插入同一条记录的问题,对于这个问题我们的解决方式是为每个写入操作添加一个分布式锁，过期时间为1s，当写同一条数据时，只有一个线程能获取到锁，未获取到锁的线程则等待其他线程写入，然后查询返回 leafID模块详细设计 维护线程池预拉取数据到db,数据默认从db中获取 当db中获取数据失败时，自动降级到远程调用 获取到的数据先全部缓存到内存队列中，所有外部调用都从队列中取值]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>美团点评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咸鱼之家今天正式成立啦]]></title>
    <url>%2F2017%2F11%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[“双11，别人在剁手，我在码代码” 前言在换了几个大众化的博客之后终于想要自己来搭一个博客环境了。 当然作为一个只会html，css，JavaScript等单词拼写的人 写前端是不会写的，只能勉强靠着copy大佬的代码才能勉强有个能看的界面这个样子 于是周末花了一天时间找了一堆大佬们模板，最终选择了用这个看这里 毕竟反正自己不会写，用哪个都是一样的 正文以后打算在这里写一写平时自己学到的新姿势，生活中的一些瞎想等等 欢迎各位基佬前来围观 —— kep 于 2017年 11.11]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
</search>
