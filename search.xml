<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux文件系统]]></title>
    <url>%2F2019%2F03%2F02%2Flinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[哈哈哈哈哈]]></content>
      <tags>
        <tag>linux 操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019新年计划]]></title>
    <url>%2F2019%2F01%2F01%2F2019%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[做一只有理想的咸鱼 过去的2018今天加完班回家，看了一下之前定的2018年年度计划： 1.早起，不晚于8点(晚上早点睡，不然头发没了) 2.减肥，到120(一把辛酸泪) 3.制定好未来的发展计划(去一个更大的厂搬砖?) 4.学好英语，看美剧不要字幕(我们的目标是星辰大海，但是首先得能够把地球走遍不是么) 5.脱单 认真想了一下完成情况 1. 大概有3个月时间是完美完成了的，但是自从来了杭州后，再也没有早睡过 2. 减肥大计一度成功，距离120只差一丝，但来到杭州后又反弹回去了 3. 目前来看确实是到了一个更大的厂搬砖，但是依然不知道未来是什么样 4. 英语学习也断了 5. 这个倒是完美完成了 所以总结一下，2018年的目标，整体上只完成了一半，甚是羞愧。 从今天开始的20192019到了，自己也过了本命年了，在成为老东西的道路上越走越远了，时间也越来越少了，因此，今年是最为关键的一年，有很多想要完成的事，在今年一定要完成掉！ 暂时先拟一下todoList： 要做的事 完成指标 完成时间点 英语学习 1.记完扇贝单词书中剩余的所有单词2.做完3本《英语在用》 2019年全年 减肥 减到120斤以下 2月4号前减到130以下3月4号前完成目标 早起 1.工作日8点前起床2.非工作日8点半起床 2019年全年 阅读 目前购买的所有书籍需要看完 2019年全年 不当码农 1.linux完全掌握，原理完全弄懂，常用命令行熟悉，shell熟悉2.网络通信完全熟悉，了解tpc/ip等底层协议，熟悉网络通信硬件架构3.学习安全方面知识，做一只菜鸡黑客4.做一个开源项目的commiter 2019年全年 高薪java码农 1.java多线程、io等基础知识完全吃透，过一遍源码2.spring核心源码过一遍3.阿里主要中间件(rpc/mq/缓存/降级/数据库路由/配置中心)源码过一遍、外部的如redis/zk/netty等常用中间件，也需要过一遍4.DDD相关概念学习5.读JVM源码，不需要读完，开始读就好 2019年上半年完成前4，剩余部分年底完成 吉他学习 会弹唱3首以上歌曲 2019年全年 攒钱计划 攒够60W 2019年全年]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>新年计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我当程序员这几年]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%88%91%E5%BD%93%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E5%87%A0%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[梳理一下作为一个程序员应该有的技术栈]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人对高并发服务的理解]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结一下 前言本文主要是简单介绍一下一个服务由单机部署到分布式部署，访问流量从低到高，这个过程中，我们所使用到的相关技术，以及需要主要到的点 由于本人水平极其有限，因此有什么错误的地方(感觉会有很多)欢迎大家指出 一些概念： 多核cpu以及超线程技术： 逻辑cpu核数: 物理cpu数 * cpu 核数 * 超线程数 cpu的load average：即cpu当前负载，举个栗子，若一个cpu1分钟能够处理的进程数是100，然后在这一分钟内只有20个进程需要被处理，那么当前cpu的负载为20/100 = 0.2通常一台机器的load average不应当超过0.7 * 逻辑cpu核数，当超过了就应当去查找原因，要是达到 1.0 * 逻辑cpu核数 那么就必须要想办法降下来 QPS(Query Per Second):即每秒查询率,是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准 TPS(TransactionPerSecond):即每秒事务处理量，指每秒钟系统能够处理的交易或事务的数量 提高单机性能-多线程技术：多线程是否一定能提升效率：首先需要明确一点，多线程只是将一个大的计算任务分为了多个并行的小的计算任务，这些拆分出来的任务还是需要分别去抢占cpu时间片，总体需要花费的时间并没有减少，只是使得任务可以并行执行 因此多线程能够提升程序执行效率的一个关键点是这台机器上的cpu，如果是单核的话，多线程反而比单线程慢因为增加了上下文切换的开销，同时对于多核cpu来说线程数也不是越多越好，举个例4核8线程的cpu 能够同时处理的任务也就8个，起再多线程也没用，反而会增加不必要的开销，通常来说保证同时处理的 线程数 = N(CPU核心数) + 1 能使系统效率达到最优，当然这里是指计算密集型线程，如果是io密集型的话可以适当增加线程数因为io线程并不一定会去抢占cpu 关于线程安全：什么是线程安全，感觉说法很多，个人理解线程安全问题就是你写的代码在多线程的情况下执行结果没有达到期望的目标比如hashmap在多线程的场景下在resize的时候有一定几率导致死循环，以及多个线程同时对同一个变量进行compare and set操作等总结了一下能产生线程安全的一个必要条件就是先得有多个线程同时访问并操作同一个数据，所以我们在写代码的时候需要注意当定义了一个static 类型的变量，或者是类成员变量时需要考虑是否会出现线程安全问题如果有可能出现线程安全问题，首先可以考虑一下用threadLocal能否解决问题，如果不能则需要考虑合理使用锁（不论是synchronized关键字还是lock类），但是使用锁的时候也需要注意是否会出现两个线程循环依赖，导致出现死锁的情况。 集群化服务-分布式部署：所谓分布式服务，个人理解就是服务和资源分散部署到不同的机器上使用原因是因为单机部署存在一个机器性能瓶颈，以及单点问题，所以线上所有服务都是多机部署的。当线上的流量变大了之后，以及提供服务的机器多了之后，如何去分发这些流量，以及流量都应该分发到哪台机器上这就是负载均衡解决的问题 流量转发-负载均衡：负载均衡分为4层负载均衡和7层负载均衡，其中4层负载均衡作用于OSI模型的第四层传输层，这一层主要的协议是tcp和udp，由此可以知道这一层负载均衡的作用主要是对数据包的转发通常客户端的流量过来了之后到达4层负载均衡，然后4层负载均衡通过修改数据包的地址信息将流量转发到应用服务器 7层负载均衡的话作用于OSI模型的第7层应用层，主要工作为代理，在将应用层的流量完整解析出来之后，7层负载均衡会新建一个连接到实际需要访问的机器上，将解析出的请求投递过去 公司现状：4层负载均衡使用的自研mgw，7层(web端)用的nginx或者Tengine，然后实际到service端的时候是使用的rpc服务自带的负载均衡附上一篇文章 MGW RPCRPC服务主要是为了简化部署在不同机器上的不同服务之间的相互调用不多讲，甩篇文章先 RPC 数据量日益增加-分库分表：现在线上提供服务的机器已经由一台变成多台了，并且能够水平扩展，因此在某种程度上已经解决了高访问量的问题(其实并没有)加机器就好了嘛，但接下来还是会遇到各种各样的问题首先一个比较容易想到的是当服务在线运行时间比较久或者访问量比较大之后，通常会导致数据库中或者表中的数据量越来越大，当数据量大了之后不论是插入还是查询都会变慢长此以往，直接就会导致我们的服务不可用,并且这种场景下扩几台应用机都没用，那么机智的小伙伴肯定想到了，扩应用机没用，扩DB不就行了么，答案确实是这样的，只不过我们用了一个比较高端的名词–分库分表所谓分库分表，其实就是将一个库或者表的数据分散到不同的库，或者不同的表中，然后通过提前定义好的分库规则和分表规则去访问不同库表，降低单库单表访问压力提高读写性能(ps:其实分库分表的前置技术栈还有一个读写分离技术，篇幅有限，就不说了，大致提一句就是单库写，多库读) 一些关注点分库分表的临界值 单表数量不超过1000万 单库数据量不超过300G 分库分表之后会遇到的问题 基本的数据库增删改功能 分布式id 分布式事务 动态扩容 使用zebra进行分库分表： 最后甩个链接 zebra 读多写少-缓存的使用：当把数据量的问题解决了之后，随着业务的发展服务访问量日益增加，你会发现读写分离+分库分表能处理的请求量(这里指qps或Tps，不过通常都是读压力比较大)还是有限，这就是所谓的DB瓶颈针对这种情况一个常用的优化措施就是缓存，利用缓存的高吞吐量的特性，在db前部署一层缓存可以大大降低db的负载，同时通常缓存响应的速度比db快(内存缓存)，因此在提高吞吐量的情况下还提高了访问速度，简直妙啊 redis和tair介绍:redis 纯内存K-V缓存，支持5种数据结构String、Hash 、List 、 Set 、 ZSet tair 淘宝开源 内存结构主要看存储引擎选择，例如MDB，LDB等 具体可见jiajun大佬的分享: 大佬的分享Redis AND 大佬的分享Tair 使用缓存需要注意的问题 缓存穿透通常在缓存未命中的情况下我们回去db再查一次数据，要是有人使用不存在的key来请求，那么流量就相当于直接落在db上 解决方案：访问db前进行合理性校验 缓存击穿单个key在过期的一瞬间被大量请求访问 解决方案：在访问db前，先加个互斥锁，例如setnx 缓存雪崩批量key在同一时间过期，大量请求直接到达db，然后db负载飙升，引起雪崩 解决方案：采用不同的过期时间，例如在固定过期时间的基础上加上一个随机值 不必要流程的异步化-MQ：那么在原有的系统上加上一层缓存之后就可以高枕无忧了么，答案当然是NO，下面列举一些场景： 写流量非常高 缓存通常只被用来解决读性能问题，最终数据一致性还是要靠db来保证(其实就是要把数据刷到磁盘上)，因此不可能将所有的写都放到缓存上 瞬时流量暴增 系统流量在短时间内倍增，例如节日或者活动期间，突发流量很有可能将缓存直接压垮，然后系统GG 针对这些问题，乍一看似乎是没什么好的办法可以解决了(其实有，但是我不知道)，不过针对某些特殊的场景我们还是可以优化一下的比如： 我如果能减少每个请求的处理时间，那么是不是就能够提高我单机的qps，那么瞬时流量来的时候是不是就不至于压夸整个系统了 对于写请求的话如果对于响应时间的要求不是那么高，那么先把这些请求都保存下来，然后慢慢处理不就好了 针对第一种优化方案，我们能想到的一个点是将系统流程中的一些不那么重要的分支流程由同步改为异步，例如更新缓存的操作然后第二种优化方案其实也是一种异步化的思想，将同步的事改为异步去做，只要保证最终一致性就好了。 那么怎么来实现这种异步化操作呢，这个时候就轮到MQ(MessageQueue)大佬出场了。 所谓MQ，其实就是一个生产者-消费者模型，producer负责生产消息，然后consumer消费消息，中间还有一个broker用来保存生产的消息像我们刚才说的这些场景我们可以让我们的服务器既作producer又做consumer，将需要异步处理的任务统统先发送到broker,然后慢慢取回来消费当然MQ也并没有我说的这么简单，篇幅有限加上个人能力有限我这里就不细说了，具体可以看看我司大佬的博文 这个是大佬文章 kafka介绍:我司使用的MQ是mafka，其实就是封装了一下kafka，针对kafka篇幅有限加上个人能力有限也不细说了，简单介绍一下 提升可用性-限流和熔断降级：当系统的可用性依赖与其他服务的可用性时，熔断降级机制是提升系统本身可使用性的一大利器同时针对突发流量，限流工具的使用也是相当有必要的 rhino介绍：Rhino]]></content>
  </entry>
  <entry>
    <title><![CDATA[java程序员基本素养(二) 更复杂的java程序]]></title>
    <url>%2F2018%2F07%2F19%2Fjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB2%2F</url>
    <content type="text"><![CDATA[何如使用中间件，工具等只是术的层次，我们更需要关注背后的道的层次 io要写功能更强大的程序，不可避免要涉及io，不论是从文件中获取还是从网络中获取 java.io 库 待填坑 bio、nio、aio 对比 待填坑 我司大佬写的NIO 网络编程除非你一直都是写单机程序自娱自乐，不然我们总会需要将自己的服务发布到网络上 java网络编程 待填坑 多线程现在的计算机通常都不止一个CPU，同时由于CPU的超线程技术，可以使一个CPU同时处理两个线程，使得计算机的计算能力大幅提升为了更好地压榨机器的性能，多线程编程技术必不可少 Java多线程 待填坑 ThreadPoolExecutor 我写的]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>java程序员基本素养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java程序员基本素养(一) 从java文件到在JVM中运行]]></title>
    <url>%2F2018%2F07%2F12%2Fjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB%2F</url>
    <content type="text"><![CDATA[个人理解的作为一个java程序员应当有的基本素养系列，只维护一个目录作为查缺补漏用 .java 文件java 码农生涯的起点是从一个.java文件开始的 java语法 待填坑 .class 文件.java 文件通过javac编译后每个类都会生成一个.class文件.class文件是JVM生态圈里比较重要的一部分，也是java实现跨平台部署的基础 .class 文件结构 待填坑 字节码指令含义 待填坑 这个不错 java语法如何转换为字节码(不那么重要) 待填坑 .class 文件加载进内存中要使用.class文件先得把.class文件加载到内存中 类加载机制 待填坑 内存中的.class文件如何转化为机器码字节码还是能被JVM识别，但是正在进行运算的还是机器本身，所以需要把字节码转化为可被机器识别的机器码 解释器编译器，JIT等 待填坑 GC程序运行起来之后，在运行过程中需要不断地申请和释放内存，怎么来分配和回收内存就需要我们关注一下了，我们通常使用的VM都是hotspot VMhotspot VM为我们提供了很多的垃圾收集器 JVM 内存分配方案(hotSpot) 待填坑 JVM 收集器(hotSpot) 待填坑 Java 常用调试工具(jsp,jmap,jstack等) 待填坑]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>java程序员基本素养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统一电话服务]]></title>
    <url>%2F2018%2F06%2F02%2F%E7%BB%9F%E4%B8%80%E7%94%B5%E8%AF%9D%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[统一电话服务模块化改造目标将现有服务按功能拆分为独立模块,内部系统结构改为各个模块之间通信的方式，减少冗余代码，解耦各个模块之间的依赖提高代码可读性和可维护性 模块划分经过对系统功能的梳理，一共划分为了如下5个互相解耦的模块，每个模块大致功能如下 校验及数据转化模块 系统中所有需要进行数据校验的操作，包括参数校验，返回值校验，以及需要进行数据转换的服务，包括16进制转10进制，码表转换等，由此模块对外提供 加解密模块 系统中所有需要进行加解密的操作，由此模块对外提供 存储模块 系统中所有需要进行存储的操作全部由此模块提供，包括缓存，db等，同时内置缓存同步策略，路由策略，降级策略，限流策略等 LeafID生成模块 系统内所有leafID的来源，内部包含预拉取，内存队列优化，熔断降级等策略 监控模块 负责监控系统运行状态，对数据进行分析并告警 模块通信方式目前采取的策略是，每个模块各对外暴露一个接口，再由内部实现类去对各个模块进行操作，其中监控模块采用AOP的方式，捕获其他所有模块的返回值及抛出的异常。 存储模块详细设计在所有模块中，存储模块是逻辑最复杂的一块，细分的话可以分为缓存模块和db模块。 缓存模块缓存模块作为高可用最重要的一环，因此相当重要，故而采取了以下策略，尽可能保证缓存服务的稳定 异地双中心部署 当一个请求到缓存模块时会判断地区信息，调用不同的缓存集群 熔断降级 采取redis、tair双缓存互为备份的方案,默认由redis提供服务，一旦redis出现异常，自动降级到tair 缓存结构优化(主要针对redis) 将string类型调整为hash类型，将key的数量级由亿降至百万，降低存储内存占用 db模块db主要用于保证数据可靠，因此重点在于不能有任何脏数据落库，除此之外还要保证db的高可用，不能被突增流量打垮，因此db模块工作如下： 限流 使用公司内部限流框架对写接口进行限流 分布式锁 落库操作其实是一类compareAndSet的操作，对于一条数据会首先查询db中有没有，没有再落库但是在并发量比较高的情况下多个线程同时写同一条数据的时候，会产生往数据库中插入同一条记录的问题,对于这个问题我们的解决方式是为每个写入操作添加一个分布式锁，过期时间为1s，当写同一条数据时，只有一个线程能获取到锁，未获取到锁的线程则等待其他线程写入，然后查询返回 leafID模块详细设计 维护线程池预拉取数据到db,数据默认从db中获取 当db中获取数据失败时，自动降级到远程调用 获取到的数据先全部缓存到内存队列中，所有外部调用都从队列中取值]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>美团点评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咸鱼之家今天正式成立啦]]></title>
    <url>%2F2017%2F11%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[“双11，别人在剁手，我在码代码” 前言在换了几个大众化的博客之后终于想要自己来搭一个博客环境了。 当然作为一个只会html，css，JavaScript等单词拼写的人 写前端是不会写的，只能勉强靠着copy大佬的代码才能勉强有个能看的界面这个样子 于是周末花了一天时间找了一堆大佬们模板，最终选择了用这个看这里 毕竟反正自己不会写，用哪个都是一样的 正文以后打算在这里写一写平时自己学到的新姿势，生活中的一些瞎想等等 欢迎各位基佬前来围观 —— kep 于 2017年 11.11]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
</search>
